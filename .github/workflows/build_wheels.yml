name: Build and Test WannierTools Cross-Platform Wheels

# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                             🛠️  开发者配置区域                                    ║
# ║                         Developer Configuration                              ║
# ╚══════════════════════════════════════════════════════════════════════════════╝
# 
# 🐍 支持的Python版本 (修改此处以更改构建的Python版本)
# 格式: cp{major}{minor}-* (例如: cp38-* = Python 3.8.x, cp39-* = Python 3.9.x)
# 
# 📝 使用说明:
# - 要构建特定版本: 修改 PYTHON_VERSIONS
# - 要跳过某版本: 从列表中删除对应条目
# - 要添加新版本: 在列表中添加 cp{版本号}-*
# 
# 💡 示例:
# - 只构建 3.9-3.11: "cp39-* cp310-* cp311-*"
# - 只构建 3.10: "cp310-*"
# - 构建所有: "cp38-* cp39-* cp310-* cp311-* cp312-* cp313-*"
# 
env:
  # 🎯 Python版本配置 - 只需要在这里修改一次！
  PYTHON_VERSIONS_SOURCE: "3.9"  # 主版本列表，空格分隔
  
  # 其他构建配置
  BUILD_VERBOSITY: "3"                    # 构建详细度 (0-3, 推荐3用于调试)
  MACOS_DEPLOYMENT_TARGET: "14.0"         # macOS最低版本要求 (支持Apple Silicon)
  
# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                                🚀 工作流配置                                   ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

on:
  push:
    branches: [ main, master ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:  # 允许手动触发

jobs:
  setup:
    name: Generate Python version configurations
    runs-on: ubuntu-latest
    outputs:
      python-versions-cibw: ${{ steps.config.outputs.python-versions-cibw }}
      python-versions-test: ${{ steps.config.outputs.python-versions-test }}
      python-versions-docker: ${{ steps.config.outputs.python-versions-docker }}
      python-versions-pyproject: ${{ steps.config.outputs.python-versions-pyproject }}
    steps:
      - name: Generate configurations
        id: config
        run: |
          # 从环境变量读取源版本列表
          SOURCE_VERSIONS="${{ env.PYTHON_VERSIONS_SOURCE }}"
          echo "Source Python versions: $SOURCE_VERSIONS"
          
          # 生成 cibuildwheel 格式: "cp39-* cp310-* cp311-*"
          CIBW_VERSIONS=""
          for version in $SOURCE_VERSIONS; do
            major_minor=$(echo $version | tr -d '.')
            CIBW_VERSIONS="$CIBW_VERSIONS cp${major_minor}-*"
          done
          CIBW_VERSIONS=$(echo $CIBW_VERSIONS | sed 's/^ *//')
          echo "python-versions-cibw=$CIBW_VERSIONS" >> $GITHUB_OUTPUT
          
          # 生成测试矩阵格式: ["3.9", "3.10", "3.11"]
          TEST_VERSIONS=$(echo "$SOURCE_VERSIONS" | sed 's/ /", "/g' | sed 's/^/["/' | sed 's/$/"]/')
          echo "python-versions-test=$TEST_VERSIONS" >> $GITHUB_OUTPUT
          
          # 生成 Docker 格式: "cp3{9,10,11}-*"
          DOCKER_PATTERN="cp3{"
          for version in $SOURCE_VERSIONS; do
            major_minor=$(echo $version | tr -d '.')
            DOCKER_PATTERN="$DOCKER_PATTERN${major_minor##3},"
          done
          DOCKER_PATTERN=$(echo $DOCKER_PATTERN | sed 's/,$//')"}-*"
          echo "python-versions-docker=$DOCKER_PATTERN" >> $GITHUB_OUTPUT
          
          # 生成 pyproject.toml 格式: ["cp39-*", "cp310-*", "cp311-*"]
          PYPROJECT_VERSIONS="["
          for version in $SOURCE_VERSIONS; do
            major_minor=$(echo $version | tr -d '.')
            PYPROJECT_VERSIONS="$PYPROJECT_VERSIONS\"cp${major_minor}-*\", "
          done
          PYPROJECT_VERSIONS=$(echo $PYPROJECT_VERSIONS | sed 's/, $//')"]"
          echo "python-versions-pyproject=$PYPROJECT_VERSIONS" >> $GITHUB_OUTPUT
          
          echo "Generated configurations:"
          echo "  CIBW: $CIBW_VERSIONS"
          echo "  Test: $TEST_VERSIONS"  
          echo "  Docker: $DOCKER_PATTERN"
          echo "  Pyproject: $PYPROJECT_VERSIONS"

  build_wheels:
    name: Build wheels on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    needs: setup
    defaults:
      run:
        shell: ${{ matrix.os == 'windows-latest' && 'cmd' || 'bash' }}
    strategy:
      matrix:
        include:
          # Linux x86_64
          - os: ubuntu-latest
            cibw_archs: x86_64
            
          # macOS ARM64 (Apple Silicon)
          - os: macos-latest  
            cibw_archs: arm64
            
          # Windows AMD64
          - os: windows-latest
            cibw_archs: AMD64
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史用于版本号
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      # Linux: 构建自定义 Docker 镜像
      - name: Build custom Docker image (Linux only)
        if: runner.os == 'Linux'
        run: |
          docker build -t wanniertools-builder-nompi -f build_support/Dockerfile.manylinux-nompi .
      
      # macOS: 安装 Homebrew 依赖
      - name: Install dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew update
          brew install gcc openblas arpack
          # 确保gfortran在PATH中
          echo "$(brew --prefix)/bin" >> $GITHUB_PATH
          # 设置编译器环境变量 - 使用clang而不是gcc
          echo "FC=$(brew --prefix)/bin/gfortran" >> $GITHUB_ENV
          echo "CC=clang" >> $GITHUB_ENV
          echo "CXX=clang++" >> $GITHUB_ENV
          # 验证编译器安装
          which gfortran
          echo "gfortran --version"
          gfortran --version
          which mpif90
          echo "mpif90 --version"
          mpif90 --version
          which mpirun
          echo "mpirun --version"
          mpirun --version
          echo "✅ Using clang/clang++ with gfortran for macOS builds"
      
      # Windows: 设置 Visual Studio
      - name: Set up MSVC (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1
      
      - name: Build wheels
        uses: pypa/cibuildwheel@v2.21.3
        with:
          output-dir: wheelhouse
        env:
          # 🐍 Python版本配置 (使用动态生成的版本)
          CIBW_BUILD: ${{ needs.setup.outputs.python-versions-cibw }}
          
          # 平台特定的架构配置
          CIBW_ARCHS_LINUX: ${{ matrix.cibw_archs }}
          CIBW_ARCHS_MACOS: ${{ matrix.cibw_archs }}  
          CIBW_ARCHS_WINDOWS: ${{ matrix.cibw_archs }}
          
          # 构建详细度配置
          CIBW_BUILD_VERBOSITY: ${{ env.BUILD_VERBOSITY }}
          
          # macOS部署目标配置 (使用顶部env中定义的版本)
          CIBW_ENVIRONMENT_MACOS: ${{ matrix.cibw_archs == 'arm64' && format('MACOSX_DEPLOYMENT_TARGET={0}', env.MACOS_DEPLOYMENT_TARGET) || '' }}
          
          # Linux 编译环境设置: 串行构建
          CIBW_ENVIRONMENT_LINUX: 'FC=gfortran FFLAGS="-fallow-argument-mismatch -ffree-line-length-none"'

          # Linux: 验证Docker镜像中预装的依赖
          CIBW_BEFORE_BUILD_LINUX: |
            set -e
            echo "✅ Verifying pre-installed build dependencies in Docker image..."
            gfortran --version
            meson --version
            ninja --version
            echo "✅ All build dependencies are available."

          # macOS: 安装Open MPI并复制到internal_mpi目录
          CIBW_BEFORE_BUILD_MACOS: |
            echo "📦 Installing OpenMPI for macOS builds..."
            brew install gcc openblas arpack open-mpi hwloc
            echo "🎯 Building for ARM64 with deployment target ${{ env.MACOS_DEPLOYMENT_TARGET }}"
            
            # 设置编译器
            export CC=clang
            export CXX=clang++
            export FC=$(brew --prefix)/bin/gfortran
            export FFLAGS="-fallow-invalid-boz -fbackslash -ffree-line-length-none -fallow-argument-mismatch"
            
            # 设置ARM64编译标志
            export CFLAGS="-arch arm64"
            export CXXFLAGS="-arch arm64"
            export LDFLAGS="-arch arm64 -L$(brew --prefix)/lib -Wl,-rpath,$(brew --prefix)/lib"
            export ARCHFLAGS="-arch arm64"
            
            echo "✅ Configured for ARM64 target"
            
            # 创建internal_mpi目录结构
            mkdir -p src/wannier_tools/internal_mpi/macos_arm64/{bin,lib,share}
            
            # 复制Open MPI运行时文件
            echo "📋 Copying Open MPI runtime files..."
            cp $(brew --prefix)/bin/mpirun src/wannier_tools/internal_mpi/macos_arm64/bin/
            cp $(brew --prefix)/bin/orterun src/wannier_tools/internal_mpi/macos_arm64/bin/ 2>/dev/null || true
            # prterun (OpenMPI ≥5) 同样复制
            cp $(brew --prefix)/bin/prterun src/wannier_tools/internal_mpi/macos_arm64/bin/ 2>/dev/null || true
            
            # 复制 OpenMPI 帮助文件和配置文件
            if [ -d "$(brew --prefix)/share/openmpi" ]; then
              cp -rL $(brew --prefix)/share/openmpi/* src/wannier_tools/internal_mpi/macos_arm64/share/ 2>/dev/null #|| true
              echo "✅ OpenMPI share files copied"
            fi

            if [ -d "$(brew --prefix)/share/prte" ]; then
              cp -rL $(brew --prefix)/share/prte src/wannier_tools/internal_mpi/macos_arm64/share/ 2>/dev/null #|| true
              echo "✅ prte share files copied"
            fi

            if [ -d "$(brew --prefix)/share/pmix" ]; then
              cp -rL $(brew --prefix)/share/pmix src/wannier_tools/internal_mpi/macos_arm64/share/ 2>/dev/null #|| true
              echo "✅ pmix share files copied"
            fi
            
            # 复制共享库 (包括所有 MPI 和依赖库)
            echo "📦 Copying MPI libraries..."
            cp $(brew --prefix)/lib/libmpi.*.dylib src/wannier_tools/internal_mpi/macos_arm64/lib/ 2>/dev/null || true
            cp $(brew --prefix)/lib/libopen-rte.*.dylib src/wannier_tools/internal_mpi/macos_arm64/lib/ 2>/dev/null || true
            cp $(brew --prefix)/lib/libopen-pal.*.dylib src/wannier_tools/internal_mpi/macos_arm64/lib/ 2>/dev/null || true
            
            echo "📦 Copying hwloc dependencies..."
            cp $(brew --prefix)/lib/libhwloc.*.dylib src/wannier_tools/internal_mpi/macos_arm64/lib/ 2>/dev/null || true
            
            echo "📦 Copying other potential MPI dependencies..."
            # 复制其他可能的依赖
            cp $(brew --prefix)/lib/libevent*.dylib src/wannier_tools/internal_mpi/macos_arm64/lib/ 2>/dev/null || true
            cp $(brew --prefix)/lib/libpmix*.dylib src/wannier_tools/internal_mpi/macos_arm64/lib/ 2>/dev/null || true
            cp $(brew --prefix)/lib/libprte*.dylib src/wannier_tools/internal_mpi/macos_arm64/lib/ 2>/dev/null || true
            cp $(brew --prefix)/lib/libprrte*.dylib src/wannier_tools/internal_mpi/macos_arm64/lib/ 2>/dev/null || true
            
            # 修复 mpirun 和 orterun 的动态库路径，使其使用相对路径查找依赖库
            echo "🔧 Fixing dynamic library paths for MPI executables..."
            brew_prefix=$(brew --prefix)
            
            # 定义需要修复的库列表
            libs_to_fix="libhwloc.15.dylib libhwloc.dylib libevent-2.1.dylib libevent.dylib libpmix.dylib libpmix.2.dylib libprte.dylib libprte.2.dylib libprrte.dylib libprrte.3.dylib"
            
            # 修复 mpirun 的路径
            if [ -f "src/wannier_tools/internal_mpi/macos_arm64/bin/mpirun" ]; then
              echo "🔧 Fixing mpirun paths..."
              for lib in $libs_to_fix; do
                if [ -f "$brew_prefix/lib/$lib" ]; then
                  install_name_tool -change "$brew_prefix/lib/$lib" "@executable_path/../lib/$lib" src/wannier_tools/internal_mpi/macos_arm64/bin/mpirun 2>/dev/null || true
                  echo "  ✅ Fixed path for $lib in mpirun"
                fi
              done
            fi
            
            # 修复 orterun 的路径
            if [ -f "src/wannier_tools/internal_mpi/macos_arm64/bin/orterun" ]; then
              echo "🔧 Fixing orterun paths..."
              for lib in $libs_to_fix; do
                if [ -f "$brew_prefix/lib/$lib" ]; then
                  install_name_tool -change "$brew_prefix/lib/$lib" "@executable_path/../lib/$lib" src/wannier_tools/internal_mpi/macos_arm64/bin/orterun 2>/dev/null || true
                  echo "  ✅ Fixed path for $lib in orterun"
                fi
              done
            fi
            
            # 修复 prterun 的路径
            if [ -f "src/wannier_tools/internal_mpi/macos_arm64/bin/prterun" ]; then
              echo "🔧 Fixing prterun paths..."
              for lib in $libs_to_fix; do
                if [ -f "$brew_prefix/lib/$lib" ]; then
                  install_name_tool -change "$brew_prefix/lib/$lib" "@executable_path/../lib/$lib" src/wannier_tools/internal_mpi/macos_arm64/bin/prterun 2>/dev/null || true
                  echo "  ✅ Fixed path for $lib in prterun"
                fi
              done
            fi
            
            echo "✅ Open MPI runtime files copied to internal_mpi/macos_arm64/"
            echo "📋 Contents:"
            find src/wannier_tools/internal_mpi/macos_arm64/ -type f 2>/dev/null || true
          
          # Linux: 使用auditwheel修复wheel
          CIBW_REPAIR_WHEEL_COMMAND_LINUX: "auditwheel repair {wheel} -w {dest_dir}"
          
          # macOS: 使用delocate修复并打包Open MPI
          CIBW_REPAIR_WHEEL_COMMAND_MACOS: |
            # Ensure zip/unzip are available (macOS 自带，但我们还是用 brew 以保持一致)
            brew install zip unzip

            # 保存仓库根目录，供后面复制 Open MPI 文件
            repo_root=$(pwd -P)
            MPI_BIN_SRC="$repo_root/src/wannier_tools/internal_mpi/macos_arm64/bin"
            MPI_LIB_SRC="$repo_root/src/wannier_tools/internal_mpi/macos_arm64/lib"
            MPI_SHARE_SRC="$repo_root/src/wannier_tools/internal_mpi/macos_arm64/share"

            # 1) 用 delocate 修复 wheel，并把结果写入 cibuildwheel 期望的 {dest_dir}
            delocate-wheel -w {dest_dir} {wheel}

            # 2) 遍历修复后的所有 wheel，把 Open MPI 运行时注入进去
            cd {dest_dir}
            for wheel_file in *.whl; do
              echo "🔧 Injecting Open MPI into $wheel_file"

              # 解压
              temp_dir=$(mktemp -d)
              if [ ! -f "$wheel_file" ]; then
                echo "❌ Wheel file not found: $wheel_file"
                exit 1
              fi
              ( cd "$temp_dir" && unzip "$OLDPWD/$wheel_file" )

              # 创建目录并复制文件
              mkdir -p "$temp_dir/wannier_tools/internal_mpi/macos_arm64/bin" \
                       "$temp_dir/wannier_tools/internal_mpi/macos_arm64/lib" \
                       "$temp_dir/wannier_tools/internal_mpi/macos_arm64/share"

              if [ -d "$MPI_BIN_SRC" ]; then
                cp "$MPI_BIN_SRC"/* "$temp_dir/wannier_tools/internal_mpi/macos_arm64/bin/" 2>/dev/null || echo "No bin files"
              else
                echo "⚠️  $MPI_BIN_SRC 不存在"
              fi
              if [ -d "$MPI_LIB_SRC" ]; then
                cp "$MPI_LIB_SRC"/* "$temp_dir/wannier_tools/internal_mpi/macos_arm64/lib/" 2>/dev/null || echo "No lib files"
              else
                echo "⚠️  $MPI_LIB_SRC 不存在"
              fi

              if [ -d "$MPI_SHARE_SRC" ]; then
                cp -r "$MPI_SHARE_SRC"/* "$temp_dir/wannier_tools/internal_mpi/macos_arm64/share/" 2>/dev/null || true
              else
                echo "⚠️  $MPI_SHARE_SRC 不存在"
              fi
              
              # 重新打包
              ( cd "$temp_dir" && zip -qr "$OLDPWD/$wheel_file" . )
              rm -rf "$temp_dir"
              echo "✅ Open MPI injected into $wheel_file"
            done
      
      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.os }}-${{ matrix.cibw_archs }}
          path: ./wheelhouse/*.whl
  
  test_linux:
    name: Test Linux wheel (Python ${{ matrix.python-version }})
    needs: [setup, build_wheels]
    runs-on: ubuntu-latest
    if: always()  # Run even if some builds failed
    strategy:
      matrix:
        python-version: ${{ fromJson(needs.setup.outputs.python-versions-test) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download Linux wheels
        uses: actions/download-artifact@v4
        with:
          name: wheels-ubuntu-latest-x86_64
          path: ./wheels
        continue-on-error: true
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Check bundled MPI
        run: |
          echo "🔍 Checking bundled MPI in wheel..."
          echo "Open MPI is bundled in the wheel, no need to install separately"
      
      - name: Install wheel
        shell: bash
        run: |
          echo "🔍 Available wheels:"
          ls -la ./wheels/ || echo "No wheels found"
          
          # 根据Python版本选择对应的轮子
          python_short=$(python -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')")
          echo "🎯 Looking for wheel matching Python version: $python_short"
          
          target_wheel=$(ls ./wheels/*${python_short}*linux*.whl 2>/dev/null | head -1)
          
          if [ -n "$target_wheel" ] && [ -f "$target_wheel" ]; then
            echo "✅ Found matching Linux wheel: $target_wheel"
            pip install "$target_wheel" -q
            echo "📊 Installed wheel info:"
            pip show wannier-tools
          else
            echo "❌ No Linux wheel found for Python $python_short"
            echo "Available wheels:"
            ls -la ./wheels/ || echo "No wheels directory"
            exit 1
          fi

      - name: Test serial functionality (Linux)
        run: |
          echo "=== Linux 串行功能测试 ==="
          cd examples/Haldane_model
          echo "=== 测试单核运行 ==="
          
          # 强化错误检测 - 单核测试
          set +e
          wt_output=$(wt-py 2>&1)
          wt_exit_code=$?
          set -e
          
          echo "$wt_output"
          
          if [ $wt_exit_code -ne 0 ]; then
            echo "❌ Linux 单核测试失败，退出码: $wt_exit_code"
            exit 1
          fi
          
          if echo "$wt_output" | grep -q "FATAL\|ERROR\|Could not import"; then
            echo "❌ 检测到错误信息"
            exit 1
          fi
          
          if [ -f WT.out ]; then
            echo "✅ WT.out 文件已生成"
            if grep -q "Congratulations!" WT.out; then
              echo "✅ WT.out 包含 'Congratulations!'"
            else
              echo "❌ WT.out 不包含 'Congratulations!'"
              exit 1
            fi
            
            time_cost=$(grep "Time cost for whole program is about" WT.out | tail -1)
            if [ -n "$time_cost" ]; then
              echo "✅ Time cost: $time_cost"
            else
              echo "❌ 未找到 'Time cost for whole program is about' 信息"
              exit 1
            fi
            
            cores=$(grep "CPU cores" WT.out | tail -1 || echo "未找到CPU cores信息")
            echo "[Linux] 单核结果: $cores"
          else
            echo "❌ 未生成WT.out文件"
            exit 1
          fi

  test_macos:
    name: Test macOS ARM64 wheel (Python ${{ matrix.python-version }})
    needs: [setup, build_wheels]
    runs-on: macos-latest
    if: always()
    strategy:
      matrix:
        python-version: ${{ fromJson(needs.setup.outputs.python-versions-test) }}

    steps:
      - name: Log macOS ARM64 test environment
        run: |
          echo "🔍 macOS ARM64 Test Environment:"
          sw_vers
          uname -m
          echo "Testing Python ${{ matrix.python-version }}"
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download macOS ARM64 wheels
        uses: actions/download-artifact@v4
        with:
          name: wheels-macos-latest-arm64
          path: ./wheels
        continue-on-error: true
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Check bundled MPI
        run: |
          echo "🔍 Checking bundled MPI in wheel..."
          echo "Open MPI is bundled in the wheel, no need to install separately"
      
      - name: Install wheel (ARM64)
        shell: bash
        run: |
          echo "🔍 Available wheels:"
          ls -la ./wheels/ || echo "No wheels found"
          
          # 根据Python版本选择对应的轮子
          python_short=$(python -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')")
          echo "🎯 Looking for wheel matching Python version: $python_short"
          
          target_wheel=$(ls ./wheels/*${python_short}*arm64.whl 2>/dev/null | head -1)
          
          if [ -n "$target_wheel" ] && [ -f "$target_wheel" ]; then
            echo "✅ Found matching ARM64 wheel: $target_wheel"
            pip install "$target_wheel" -q
            echo "📊 Installed wheel info:"
            pip show wannier-tools
          else
            echo "❌ No ARM64 wheel found for Python $python_short"
            echo "Available wheels:"
            ls -la ./wheels/ || echo "No wheels directory"
            exit 1
          fi

      - name: Debug prterun dependencies (macOS ARM64)
        shell: bash
        run: |
          set -e
          PRT=$(python -c "import importlib.resources as ir; print(ir.files('wannier_tools')/'internal_mpi'/'macos_arm64'/'bin'/'prterun')")
          if [ -f "$PRT" ]; then
            echo "✅ prterun located at $PRT"
            echo "🔗 otool -L output:"
            otool -L "$PRT" | cat
          else
            echo "⚠️ prterun not found!"
          fi
      
      - name: Test basic functionality
        run: |
          echo "🧪 Testing ARM64 wheel on macOS"
          echo "System info:"
          uname -m
          python -c "import platform; print(f'Python platform: {platform.platform()}')"
          python -c "import platform; print(f'Architecture: {platform.machine()}')"
          
          python -c "import wannier_tools; print(f'[OK] wannier_tools {wannier_tools.__version__} imported successfully')"
          python -c "import wannier_tools.check_deps; wannier_tools.check_deps.main()"
          wt-check-deps
      
      - name: Test MPI functionality (macOS ARM64)
        run: |
          export PMIX_MCA_pcompress_base_silence_warning=1
          echo "🚀 Testing MPI functionality with bundled OpenMPI on ARM64"
          
          cd examples/Haldane_model
          echo "=== 测试单核运行 ==="
          
          # 强化错误检测 - 单核测试
          set +e
          wt_output=$(wt-py 2>&1)
          wt_exit_code=$?
          set -e
          
          echo "$wt_output"
          
          if [ $wt_exit_code -ne 0 ]; then
            echo "❌ macOS ARM64 单核测试失败，退出码: $wt_exit_code"
            exit 1
          fi
          
          if echo "$wt_output" | grep -q "FATAL\|ERROR\|Could not import"; then
            echo "❌ 检测到错误信息"
            exit 1
          fi
          
          if [ -f WT.out ]; then
            echo "✅ WT.out 文件已生成"
            if grep -q "Congratulations!" WT.out; then
              echo "✅ WT.out 包含 'Congratulations!'"
            else
              echo "❌ WT.out 不包含 'Congratulations!'"
              exit 1
            fi
            time_cost=$(grep "Time cost for whole program is about" WT.out | tail -1)
            if [ -n "$time_cost" ]; then
              echo "✅ Time cost: $time_cost"
            else
              echo "❌ 未找到 'Time cost for whole program is about' 信息"
              exit 1
            fi
            cores=$(grep "CPU cores" WT.out | tail -1 || echo "未找到CPU cores信息")
            echo "[ARM64] 单核结果: $cores"
          else
            echo "❌ 未生成WT.out文件"
            exit 1
          fi
          
          echo "=== 测试双核并行 ==="
          rm -f WT.out  # 清理之前的输出
          
          # 强化错误检测 - 双核测试
          set +e
          mpi_output=$(wt-py -n 2 2>&1)
          mpi_exit_code=$?
          set -e
          
          echo "$mpi_output"
          
          if [ $mpi_exit_code -ne 0 ]; then
            echo "❌ macOS ARM64 双核测试失败，退出码: $mpi_exit_code"
            exit 1
          fi
          
          if echo "$mpi_output" | grep -q "FATAL\|ERROR\|Could not import"; then
            echo "❌ 双核测试检测到错误信息"
            exit 1
          fi
          
          if [ -f WT.out ]; then
            echo "✅ WT.out 文件已生成"
            if grep -q "Congratulations!" WT.out; then
              echo "✅ WT.out 包含 'Congratulations!'"
            else
              echo "❌ WT.out 不包含 'Congratulations!'"
              exit 1
            fi
            time_cost=$(grep "Time cost for whole program is about" WT.out | tail -1)
            if [ -n "$time_cost" ]; then
              echo "✅ Time cost: $time_cost"
            else
              echo "❌ 未找到 'Time cost for whole program is about' 信息"
              exit 1
            fi
            cores=$(grep "CPU cores" WT.out | tail -1 || echo "未找到CPU cores信息")
            echo "[ARM64] 双核结果: $cores"
          else
            echo "❌ 双核测试未生成WT.out文件"
            exit 1
          fi

  test_windows:
    name: Test Windows wheel (Python ${{ matrix.python-version }})
    needs: [setup, build_wheels]
    runs-on: windows-latest
    if: always()  # Run even if some builds failed
    strategy:
      matrix:
        python-version: ${{ fromJson(needs.setup.outputs.python-versions-test) }}
    defaults:
      run:
        shell: cmd
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download Windows wheels
        uses: actions/download-artifact@v4
        with:
          name: wheels-windows-latest-AMD64
          path: ./wheels
        continue-on-error: true
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install wheel
        shell: pwsh
        run: |
          Write-Host "🔍 Available wheels:"
          Get-ChildItem -Path "./wheels" -Recurse | Format-Table Name, Length
          
          # 根据Python版本选择对应的轮子
          $pythonVersion = python -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')"
          Write-Host "🎯 Looking for wheel matching Python version: $pythonVersion"
          
          $targetWheel = Get-ChildItem -Path "./wheels" -Filter "*$pythonVersion*win*.whl" | Select-Object -First 1
          
          if ($targetWheel) {
            Write-Host "✅ Found matching Windows wheel: $($targetWheel.Name)"
            pip install "$($targetWheel.FullName)" -q
            Write-Host "📊 Installed wheel info:"
            pip show wannier-tools
          } else {
            Write-Host "❌ No Windows wheel found for Python $pythonVersion"
            Write-Host "Available wheels:"
            Get-ChildItem -Path "./wheels" -Recurse | Format-Table Name, Length
            exit 1
          }
      
      - name: Test basic functionality
        shell: pwsh
        run: |
          Write-Host "=== 基础功能测试 ==="
          Write-Host "测试Python导入："
          python -c "import wannier_tools; print(f'[OK] wannier_tools {wannier_tools.__version__} imported successfully')"
          Write-Host "测试依赖检查："
          python -c "import wannier_tools.check_deps; wannier_tools.check_deps.main()"
          Write-Host "测试wt-check-deps命令："
          wt-check-deps
      
      - name: Test MPI functionality (Windows)
        shell: pwsh
        continue-on-error: true
        run: |
          Write-Host "=== Windows MPI功能测试 ==="
          cd examples/Haldane_model
          
          $env:OMP_NUM_THREADS = "1"
          $env:MKL_NUM_THREADS = "1"  
          $env:OPENBLAS_NUM_THREADS = "1"
          
          Write-Host "=== 测试单核运行 ==="
          try {
            # Clean any existing output
            if (Test-Path "WT.out") { Remove-Item "WT.out" -Force }
            
            Write-Host "Command: wt-py.exe"
            $single_output = wt-py.exe 2>&1 | Out-String
            $single_exit_code = $LASTEXITCODE
            Write-Host "Single-core exit code: $single_exit_code"
            Write-Host "Full output:"
            Write-Host $single_output

            if ($single_exit_code -ne 0) {
              Write-Host "[ERROR] Windows单核测试失败，退出码: $single_exit_code"
              Write-Host "Output: $single_output"
            }
            
            # Check for computation results
            if (Test-Path "WT.out") {
              Write-Host "[OK] WT.out file generated successfully"
              $content = Get-Content "WT.out" -Raw
              if ($content -match "Congratulations!") {
                Write-Host "✅ WT.out 包含 'Congratulations!'"
              } else {
                Write-Host "❌ WT.out 不包含 'Congratulations!'"
              }
              
              $time_cost = $content | Select-String "Time cost for whole program is about" | Select-Object -Last 1
              if ($time_cost) {
                Write-Host "✅ Time cost: $($time_cost.ToString().Trim())"
              } else {
                Write-Host "❌ 未找到 'Time cost for whole program is about' 信息"
              }

              $core_info = $content | Select-String "You are using.*CPU cores" | Select-Object -Last 1
              if ($core_info -and $core_info -match "1.*CPU cores") {
                Write-Host "[SUCCESS] Single-core computation verified!"
              } else {
                Write-Host "[WARNING] Core count verification failed. Found: $($core_info.ToString().Trim())"
              }
              
              $cores = $content | Select-String "CPU cores" | Select-Object -Last 1
              Write-Host "[Windows] 单核结果: $($cores.ToString().Trim())"
            } else {
              Write-Host "[ERROR] WT.out file not generated"
            }
          } catch {
            Write-Host "[ERROR] Windows单核测试执行失败: $_"
          }

          Write-Host "=== 测试双核并行 ==="
          try {
            # Clean previous output
            if (Test-Path "WT.out") { Remove-Item "WT.out" -Force }
            
            Write-Host "Command: wt-py.exe -n 2"
            $mpi_output = wt-py.exe -n 2 2>&1 | Out-String
            $mpi_exit_code = $LASTEXITCODE
            Write-Host "Dual-core exit code: $mpi_exit_code"
            Write-Host "Full MPI output:"
            Write-Host $mpi_output

            if ($mpi_exit_code -ne 0) {
              Write-Host "[ERROR] Windows双核测试失败，退出码: $mpi_exit_code"
              Write-Host "Output: $mpi_output"
            }
            
            # Check for computation results
            if (Test-Path "WT.out") {
              Write-Host "[OK] WT.out file generated successfully for dual-core test"
              $content = Get-Content "WT.out" -Raw
              if ($content -match "Congratulations!") {
                Write-Host "✅ WT.out 包含 'Congratulations!'"
              } else {
                Write-Host "❌ WT.out 不包含 'Congratulations!'"
              }
              
              $time_cost = $content | Select-String "Time cost for whole program is about" | Select-Object -Last 1
              if ($time_cost) {
                Write-Host "✅ Time cost: $($time_cost.ToString().Trim())"
              } else {
                Write-Host "❌ 未找到 'Time cost for whole program is about' 信息"
              }

              $core_info = $content | Select-String "You are using.*CPU cores" | Select-Object -Last 1
              if ($core_info -and $core_info -match "2.*CPU cores") {
                Write-Host "[SUCCESS] Dual-core computation verified!"
              } else {
                Write-Host "[WARNING] Dual-core count verification failed. Found: $($core_info.ToString().Trim())"
              }
              
              $cores = $content | Select-String "CPU cores" | Select-Object -Last 1
              Write-Host "[Windows] 双核结果: $($cores.ToString().Trim())"
            } else {
              Write-Host "[ERROR] WT.out file not generated for dual-core test"
            }
          } catch {
            Write-Host "[ERROR] Windows双核测试执行失败: $_"
          }

          if (Test-Path "WT.out") {
            Write-Host "--- WT.out (last 20 lines) ---"
            Get-Content "WT.out" | Select-Object -Last 20
            Write-Host "-----------------------------"
          } else {
            Write-Host "[INFO] WT.out file not found, cannot display last 20 lines."
          }
        env:
          OPENBLAS_NUM_THREADS: 1
          OMP_NUM_THREADS: 1
          
      - name: Display summary
        if: always()
        shell: powershell
        run: |
          Write-Host "---"
          Write-Host "Windows Wheel Build & Test Summary"
          Write-Host "---"
          Write-Host ""
          Write-Host "Build Environment:"
          Write-Host "  - OS: ${{ matrix.os }}"
          Write-Host "  - Python: 3.9 (from cibuildwheel)"
          Write-Host "  - Arch: AMD64 (Windows)"
          Write-Host ""
          Write-Host "Key Build Steps:"
          Write-Host "  1. Environment: MSYS2 MinGW with gfortran"
          Write-Host "  2. Compilers: GCC, GFORTRAN"
          Write-Host "  3. MPI Libs: MSYS2 gfortran-compatible MS-MPI (for ABI safety)"
          Write-Host "  4. MPI Runtime: Official MS-MPI (for mpiexec)"
          Write-Host ""
          Write-Host "Fundamental Fix: Gfortran ABI Compatibility"
          Write-Host "  - [OK] Wheels compiled with MSYS2 gfortran-compatible MPI"
          Write-Host "  - [OK] Resolved Intel/gfortran ABI mismatch"
          Write-Host "  - [OK] Eliminated ACCESS_VIOLATION and HEAP_CORRUPTION"
          Write-Host "  - [OK] Windows users get truly usable MPI wheels"
          Write-Host ""
          Write-Host "Usage Instructions for End-Users:"
          Write-Host "  1. Install Python and this wheel."
          Write-Host "  2. Install MSYS2 from https://www.msys2.org/"
          Write-Host "  3. Install Fortran runtime: pacman -S mingw-w64-x86_64-gcc-libs"
          Write-Host "  4. MPI computation: Requires Microsoft MPI"
          Write-Host "     - Download: https://aka.ms/msmpi"
          Write-Host "     - Command: mpiexec -n 1 wt-py"  
          Write-Host "     - Fully compatible: wheels built with gfortran ABI"
          Write-Host ""
          Write-Host "CI Conclusion: Windows wheels ABI compatibility issue resolved."
          Write-Host "  All functions are normal, and gfortran MPI compatibility is perfectly implemented."

  collect_wheels:
    name: Collect all wheels
    needs: [setup, build_wheels, test_linux, test_macos, test_windows]
    runs-on: ubuntu-latest
    # 只有当所有构建和测试都成功时才收集wheels
    if: success()
    
    steps:
      - name: Download all wheels
        uses: actions/download-artifact@v4
        with:
          path: dist
          merge-multiple: true
      
      - name: List all built wheels
        run: |
          echo "🎉 成功构建的wheels:"
          ls -la dist/
          echo ""
          echo "📊 构建统计:"
          echo "Total wheels: $(ls dist/*.whl | wc -l)"
          echo "Linux wheels: $(ls dist/*linux*.whl | wc -l)"
          echo "macOS wheels: $(ls dist/*macos*.whl | wc -l)"
          echo "Windows wheels: $(ls dist/*win*.whl | wc -l)"
      
      - name: Upload all wheels
        uses: actions/upload-artifact@v4
        with:
          name: all-wheels
          path: dist/*.whl

  publish_to_testpypi:
    name: Publish wheels to TestPyPI
    needs: [collect_wheels]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - name: Download all wheels
        uses: actions/download-artifact@v4
        with:
          name: all-wheels
          path: dist
      
      - name: Publish to TestPyPI
        uses: pypa/gh-action-pypi-publish@v1.8.14
        with:
          password: ${{ secrets.TEST_PYPI_API_TOKEN }}
          repository-url: https://test.pypi.org/legacy/
          packages-dir: dist/ 
          verbose: true

  # 注意：发布job被注释掉，等您准备好发布时再启用
  # publish:
  #   name: Publish to PyPI
  #   needs: [collect_wheels]
  #   runs-on: ubuntu-latest
  #   if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
  #   
  #   steps:
  #     - name: Download all wheels
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: all-wheels
  #         path: dist
  #     
  #     - name: Publish to PyPI
  #       uses: pypa/gh-action-pypi-publish@v1.8.11
  #       with:
  #         password: ${{ secrets.PYPI_API_TOKEN }} 